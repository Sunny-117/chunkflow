你是一名**资深前端架构师 & 开源项目维护者**，需要设计并实现一个**通用的大文件上传 SDK**，覆盖从小文件到超大文件的所有上传场景。抽象出**可复用、可扩展、可拆分使用**的文件上传通用解决方案，并以**开源项目标准**交付，请生成中文 spec。

> ⚠️ 目标不是“做一个 Demo”，而是一个**可以被真实业务采用的工程级 SDK**。

------

## 一、总体目标

- 提供一套 **通用的大文件上传解决方案**
- 支持：
  - 小文件直传
  - 大文件分片
  - 流式上传
  - 断点续传
  - 并发控制
  - 秒传（可选）
  - 错误处理/重试
- **架构高度解耦**：
  使用者可以只用其中一个子包，而不必接入整套系统

------

## 二、技术架构约束（必须遵守）

### 1. Monorepo & 构建体系

- pnpm + monorepo

- turbo 进行任务调度

- 目录结构示例&架构分层参考：

  ```
  packages/
  	protocol (协议层)
    core/        // 抽象，不绑定任何前端框架。无前端依赖，事件系统，发布订阅模式，前后端通用，并发任务调度，可配置并发数，支持 pause / resume / drain，协议字段构造与解析工具，⚠️ upload-core 不允许出现任何 UI、DOM、请求库代码
    shared/     // 工具库
    upload-client-react（前端上传 SDK-React 适配层） 
    upload-client-vue（前端上传 SDK-Vue 适配层）
    upload-component-vue（前端组件 Vue SDK）
    upload-component-react（前端组件 React SDK）
    upload-server（BFF SDK，可选接入，也可以自定制）
  apps/
    playground/ // 演示 & 调试
    server/     // Nest.js 服务端（可以继续拆分子包，比如主服务包、鉴权包、分片包、HTTP接入包、WebSocket接入包...）
    website/    // 官方文档站点
  ```

- SDK 构建：
  - TypeScript + ESM
  - 使用 `tsdown`
- 项目启动：
  - docker-compose 启动服务端与数据库

------

### 2. SDK 分层设计原则（重点）

- **Core 层**
  - 不依赖 Vue / React
  - 只定义：
    - 协议
    - 状态机
    - 生命周期
    - Hook / Plugin 机制
- **Adapter 层**
  - Vue / React 仅做“绑定”
  - 不允许出现核心逻辑
  - 组件设计
    - props、事件、状态
    - 拖拽上传、多文件选择
    - 通用化不同文件的上传,上传统一协议
- **Shared**
  - 并发控制、事件系统、工具函数等

👉 即使用户**不用你整个 SDK**，也能只使用某一个子包解决问题。

------

### 3. 服务端技术栈

- Node.js + Nest.js
- Fastify Adapter
- PostgreSQL
- 架构要求：
  - 接口职责清晰
  - 上传协议清晰
  - 可扩展（支持多存储后端）

------

### 4. 代码质量与工程规范

- Lint & Format
  - oxlint
  - oxfmt
  - lint-staged
- 单元测试
  - Vitest
  - **只测试有业务价值的核心逻辑**
  - 保证测试速度与可维护性

------

## 三、前端上传方案设计重点

- 支持：
  - 流式处理
  - 分片上传
  - 断点续传
- 存储方案不强绑定：
  - 可以提供 BFF 思路，不强制 BFF
  - 允许使用方自定义上传元数据存储策略
- 协议与实现解耦：
  - SDK 只依赖协议
  - 具体存储、鉴权、落盘逻辑由使用方决定

------

## 四、后端方案设计要求

### 必须满足：

1. **大文件 & 小文件区别对待**
   - 可拆分接口
   - 或同接口不同上传模式
2. **协议层不限制**
   - HTTP
   - WebSocket
   - 设计为可扩展
3. **鉴权机制**
   - 定义通用协议
   - 允许使用方自定义实现符合其业务的鉴权规范、userId、ak/sk等

------

## 五、设计模式 & 技术选型原则

- 优先使用成熟第三方库
  - 事件系统：`mitt`
  - 并发控制：`p-limit`
- 避免重复造轮子
- 合理使用：
  - 策略模式
  - 模板方法
  - AOP
  - 函数式编程优先
  - **仅在非常合适的场景使用 class**

------

## 六、Playground 界面设计 Prompt（原样保留）

```
你是一位资深独立设计师,专注于《反主流》的网页美学。
你鄙视千篇一律的 Saas 模板,认为软件界面应该有触感和灵魂。

你的创意边界:
- 现代但不要紫色 → 深灰 + 橙色
- 极简但要有温度 → 大留白 + 手绘插画
- 科技感但不要冰冷 → 深色 + 暖色点缀

设计禁止清单:
- 紫色 / 靛蓝渐变
- 纯平背景（必须有噪点或渐变）
- Hero + 三卡片布局
- 完美居中对齐
- 空洞文案
- Emoji 作为功能图标
- ease-in-out 线性动画
```

------

## 七、发布 & 文档

- Website：
  - 使用 VitePress
  - 可直接 `sh deploy.sh` 部署到 GitHub Pages
- npm 发布：
  - changeset
  - monorepo 最佳实践
  - GitHub Release
- Readme：
  - 默认中文
  - 可切换英文
  - ❌ 不生成总结或“教学型”文档

------

## 八、用户信息（仅用于署名 & 开源）

- GitHub：Sunny-117
- Email：[zhiqiangfu6@gmail.com](mailto:zhiqiangfu6@gmail.com)





## 九、技术实现约束

一、请遵循以下**核心假设与建模前提**：

1. **大文件上传 = 不可分割大事务 → 可控的小事务集合**
2. **绝大多数上传文件都是“新文件”**
3. 文件内容一致即可视为同一文件或分片（基于内容 hash）。文件hash的计算，是为了判断文件是否存在，进而实现秒传的功能，所以我们可以参考布隆过滤器的理念, 牺牲一点点的识别率来换取时间，比如我们可以抽样算hash（此方案可以选择性开启-默认开启）

4. BFF 层作为前后端的唯一桥梁，必须被纳入整体设计

⚠️ 禁止采用「必须等待完整 hash 计算完成后才能上传」的传统阻塞式方案。


二、**性能与体验目标（强约束）**，你的实现必须满足以下目标：

- 🚫 **不允许长时间阻塞主线程**
- ✅ 文件选择后应**立刻开始上传**
- ✅ hash 计算与分片上传 **并行进行**
- ✅ 旧文件允许少量无效 hash 请求，但不得产生大文件重复上传
- ✅ 前端切片切完后,将blob,存储到IndexedDB,下次用户进来之后,嗅探一下是否存在未完成上传的切片,有就尝试继续上传
- ✅ 由于文件大小不一，我们每个切片的大小设置成固定的也有点略显笨拙，我们可以参考TCP协议的慢启动策略， 设置一个初始大小，根据上传任务完成的时候，来动态调整下一个切片的大小， 确保文件切片的大小和当前网速匹配
> TCP拥塞控制的问题
> 其实就是根据当前网络情况，动态调整切片的大小
> chunk中带上size值，不过进度条数量不确定了，修改createFileChunk， 请求加上时间统计
> 比如我们理想是30秒传递一个
> 初始大小定为1M，如果上传花了10秒，那下一个区块大小变成3M
> 如果上传花了60秒，那下一个区块大小变成500KB 以此类推
> 并发+慢启动的逻辑有些复杂，我自己还没绕明白，囧所以先一次只传一个切片，来演示这个逻辑，新建一个handleUpload1函数



三、客户端 Hash & 分片策略约束

1. Hash 计算原则

- **分片 hash 与整体 hash 均基于内容**
- hash 计算属于 CPU 密集型任务：
  - 不允许在主线程同步完成
  - Web Worker 只能解决阻塞问题，不能解决耗时问题
- **整体 hash 不作为上传前置条件**


> 计算hash耗时的问题，不仅可以通过web-workder，还可以参考React的FFiber架构，通过requestIdleCallback来利用浏览器的空闲时间计算，也不会卡死主线程

2. 上传流程约束（非常重要）

客户端上传流程必须遵循以下顺序：

```
文件选择
  ↓
立即分片 + 并发上传分片
  ↓（同时）
异步worker计算分片 hash & 文件 hash
  ↓
补充 hash 校验
```

不得实现为：

```
完整分片 → 完整 hash → 再上传（❌）
```



四、前后端通信协议设计约束

协议设计必须满足 **HTTP / WebSocket 可扩展性**，且协议层不得与具体框架绑定。

1. 创建文件协议（必须）

- 使用 **HEAD 请求**
- 仅用于：
  - 获取 `uploadToken`
  - 协商 `chunkSize`
- 不得在此阶段上传任何文件数据

2. Hash 校验协议（必须支持）

- 同一协议支持：
  - 分片 hash 校验
  - 文件整体 hash 校验
- 服务端需返回：
  - 是否已存在
  - 剩余未上传分片索引
  - 文件访问地址（若已完成）

3. 分片上传协议

- 必须支持：
  - `multipart/form-data`
  - `application/octet-stream`
- SDK 层不得绑定具体实现

4. 分片合并协议（逻辑合并）

- 合并 ≠ 物理合并
- 仅用于：
  - 校验
  - 状态更新
  - 生成访问 URL



六、分片策略设计约束（模板模式）

分片必须基于**模板方法模式**设计：

- SDK 内置多种分片策略：
  - 多线程分片
  - 时间切片分片（算hash耗时的问题，不仅可以通过web-workder，还可以参考React的Fiber架构，通过requestIdleCallback来利用浏览器的空闲时间计算，也不会卡死主线程）
- 上层应用可以：
  - 自定义分片策略
  - 仅实现 hash 计算逻辑

抽象类需负责：

- 分片生命周期
- hash 聚合
- 事件派发

子类只负责：

- **如何计算分片 hash**



七、请求控制与解耦要求

1. 请求并发控制

- 所有分片上传必须经过统一调度
- 并发数可配置
- 不得出现：
  - 请求洪水
  - 顺序上传

2. 请求库解耦（策略模式）

- SDK 不得依赖 axios / fetch / ky 等具体库
- 通过 RequestStrategy 抽象请求行为
- SDK 只负责流程控制，不负责发送请求



八、服务端存储与合并约束（关键设计点）

1. 分片与文件必须彻底解耦

- 分片：
  - 跨文件唯一
  - 永不删除
- 文件：
  - 只记录分片顺序
  - 不存储真实文件数据

2. 禁止真实物理合并

服务器 **不允许**：

- 将分片合并成大文件存储
- 删除分片文件

服务器 **必须**：

- 在访问文件时：
  - 动态读取分片
  - 使用流式管道输出



九、事件与可观测性要求

SDK 必须暴露完整事件体系，包括但不限于：

- 分片生成
- 分片上传开始 / 完成
- 上传进度变化
- 上传暂停 / 恢复
- 文件完成 / 失败

事件系统需：

- 前后端统一
- 支持多监听器
- 可用于埋点与监控



十、输出边界（防止模型跑偏）

- ❌ 不要写成教程
- ❌ 不要泛泛而谈概念
- ❌ 不要简化为 OSS SDK 方案
- ✅ 代码优先
- ✅ 架构优先
- ✅ 可拆包、可复用、可扩展





## 十、用户侧 SDK API

```js
import {uploadFile} from 'xx';

async function handleFileInputChange(evt) {   // 绑定到 <input type="file"> change 事件即可
    let file = evt.target.files[0];
    let result;
	try {
		result = await uploadFile(file, options);
	}
	catch (err) {
		// 处理上传错误
	}
	return result;
}
// 允许取消上传 CancelToken

// 错误格式化

// 自定义网络请求实现
let client = new UploadClient({
    hairuoOptions: {
        httpAgent: new (class {
            async request({method, url, data}) {
                // xhr.open(method, url);
                // xhr.send(data);
            }
        })
    }
});
let result = await client.uploadFile(file, options);
```





