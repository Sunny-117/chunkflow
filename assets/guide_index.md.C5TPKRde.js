import{_ as e,o as l,c as n,ag as i}from"./chunks/framework.C95KxxkN.js";const h=JSON.parse('{"title":"What is ChunkFlow?","description":"","frontmatter":{},"headers":[],"relativePath":"guide/index.md","filePath":"guide/index.md","lastUpdated":1769763135000}'),s={name:"guide/index.md"};function t(o,a,r,p,d,c){return l(),n("div",null,[...a[0]||(a[0]=[i(`<h1 id="what-is-chunkflow" tabindex="-1">What is ChunkFlow? <a class="header-anchor" href="#what-is-chunkflow" aria-label="Permalink to &quot;What is ChunkFlow?&quot;">â€‹</a></h1><p>ChunkFlow is a universal large file upload solution that provides a complete, production-ready SDK for handling file uploads of any size. It&#39;s designed with a layered architecture that makes it highly flexible, performant, and easy to integrate into any project.</p><h2 id="the-problem" tabindex="-1">The Problem <a class="header-anchor" href="#the-problem" aria-label="Permalink to &quot;The Problem&quot;">â€‹</a></h2><p>Uploading large files on the web is challenging:</p><ul><li><strong>Network Instability</strong>: Long uploads can fail due to network interruptions</li><li><strong>Memory Constraints</strong>: Loading entire files into memory can crash browsers</li><li><strong>Poor User Experience</strong>: Users have no visibility into upload progress or ability to pause/resume</li><li><strong>Duplicate Uploads</strong>: Same files uploaded multiple times waste bandwidth and storage</li><li><strong>Performance</strong>: One-size-fits-all approaches don&#39;t adapt to varying network conditions</li></ul><h2 id="the-solution" tabindex="-1">The Solution <a class="header-anchor" href="#the-solution" aria-label="Permalink to &quot;The Solution&quot;">â€‹</a></h2><p>ChunkFlow solves these problems with a comprehensive set of features:</p><h3 id="ğŸš€-smart-upload-strategy" tabindex="-1">ğŸš€ Smart Upload Strategy <a class="header-anchor" href="#ğŸš€-smart-upload-strategy" aria-label="Permalink to &quot;ğŸš€ Smart Upload Strategy&quot;">â€‹</a></h3><p>Automatically selects the optimal upload strategy based on file size:</p><ul><li>Files &lt; 5MB: Direct upload for speed</li><li>Files â‰¥ 5MB: Chunked upload for reliability</li></ul><h3 id="ğŸ“¦-dynamic-chunking" tabindex="-1">ğŸ“¦ Dynamic Chunking <a class="header-anchor" href="#ğŸ“¦-dynamic-chunking" aria-label="Permalink to &quot;ğŸ“¦ Dynamic Chunking&quot;">â€‹</a></h3><p>Adapts chunk size based on network conditions, similar to TCP slow start:</p><ul><li>Fast network â†’ Larger chunks (up to 10MB)</li><li>Slow network â†’ Smaller chunks (down to 256KB)</li><li>Optimizes for both speed and reliability</li></ul><h3 id="âš¡-instant-upload-deduplication" tabindex="-1">âš¡ Instant Upload (Deduplication) <a class="header-anchor" href="#âš¡-instant-upload-deduplication" aria-label="Permalink to &quot;âš¡ Instant Upload (Deduplication)&quot;">â€‹</a></h3><p>Hash-based deduplication enables instant uploads:</p><ul><li><strong>Full Instant Upload</strong>: File already exists â†’ Skip entire upload</li><li><strong>Partial Instant Upload</strong>: Some chunks exist â†’ Upload only missing chunks</li><li>Saves bandwidth and time</li></ul><h3 id="ğŸ”„-resumable-upload" tabindex="-1">ğŸ”„ Resumable Upload <a class="header-anchor" href="#ğŸ”„-resumable-upload" aria-label="Permalink to &quot;ğŸ”„ Resumable Upload&quot;">â€‹</a></h3><p>Continue from where you left off:</p><ul><li>Progress persisted to IndexedDB</li><li>Automatic recovery on page reload</li><li>Manual pause/resume controls</li></ul><h3 id="ğŸ¯-framework-agnostic" tabindex="-1">ğŸ¯ Framework Agnostic <a class="header-anchor" href="#ğŸ¯-framework-agnostic" aria-label="Permalink to &quot;ğŸ¯ Framework Agnostic&quot;">â€‹</a></h3><p>Works with any framework or vanilla JavaScript:</p><ul><li>React Hooks and Components</li><li>Vue Composables and Components</li><li>Framework-independent Core layer</li></ul><h3 id="ğŸ› ï¸-highly-extensible" tabindex="-1">ğŸ› ï¸ Highly Extensible <a class="header-anchor" href="#ğŸ› ï¸-highly-extensible" aria-label="Permalink to &quot;ğŸ› ï¸ Highly Extensible&quot;">â€‹</a></h3><p>Plugin system for custom functionality:</p><ul><li>Logging</li><li>Analytics</li><li>Custom validation</li><li>Progress tracking</li><li>And more...</li></ul><h2 id="architecture" tabindex="-1">Architecture <a class="header-anchor" href="#architecture" aria-label="Permalink to &quot;Architecture&quot;">â€‹</a></h2><p>ChunkFlow uses a layered architecture where each layer has a specific responsibility:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span></span>
<span class="line"><span>â”‚     Component Layer                 â”‚  Ready-to-use UI components</span></span>
<span class="line"><span>â”‚  (React/Vue Components)             â”‚</span></span>
<span class="line"><span>â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span></span>
<span class="line"><span>â”‚     Client Layer                    â”‚  Framework adapters</span></span>
<span class="line"><span>â”‚  (React Hooks / Vue Composables)   â”‚</span></span>
<span class="line"><span>â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span></span>
<span class="line"><span>â”‚     Core Layer                      â”‚  Upload logic &amp; state machine</span></span>
<span class="line"><span>â”‚  (UploadManager, UploadTask)       â”‚</span></span>
<span class="line"><span>â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span></span>
<span class="line"><span>â”‚     Shared Layer                    â”‚  Common utilities</span></span>
<span class="line"><span>â”‚  (Events, Concurrency, File Utils) â”‚</span></span>
<span class="line"><span>â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span></span>
<span class="line"><span>â”‚     Protocol Layer                  â”‚  Type definitions &amp; interfaces</span></span>
<span class="line"><span>â”‚  (TypeScript Types)                â”‚</span></span>
<span class="line"><span>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span></span></code></pre></div><p>Each layer is independent and can be used separately, giving you maximum flexibility.</p><h2 id="key-features" tabindex="-1">Key Features <a class="header-anchor" href="#key-features" aria-label="Permalink to &quot;Key Features&quot;">â€‹</a></h2><h3 id="parallel-hash-calculation" tabindex="-1">Parallel Hash Calculation <a class="header-anchor" href="#parallel-hash-calculation" aria-label="Permalink to &quot;Parallel Hash Calculation&quot;">â€‹</a></h3><p>Hash calculation and upload happen simultaneously:</p><ul><li>Don&#39;t wait for hash to complete before starting upload</li><li>Cancel ongoing upload if file already exists</li><li>Prioritize first few chunks for quick feedback</li></ul><h3 id="concurrency-control" tabindex="-1">Concurrency Control <a class="header-anchor" href="#concurrency-control" aria-label="Permalink to &quot;Concurrency Control&quot;">â€‹</a></h3><p>Smart management of parallel uploads:</p><ul><li>Configurable concurrent chunk uploads (default: 3)</li><li>Queue management for optimal resource usage</li><li>Dynamic adjustment based on performance</li></ul><h3 id="error-handling-retry" tabindex="-1">Error Handling &amp; Retry <a class="header-anchor" href="#error-handling-retry" aria-label="Permalink to &quot;Error Handling &amp; Retry&quot;">â€‹</a></h3><p>Robust error handling with automatic retry:</p><ul><li>Exponential backoff strategy</li><li>Configurable retry count and delay</li><li>Graceful degradation when features unavailable</li></ul><h3 id="progress-tracking" tabindex="-1">Progress Tracking <a class="header-anchor" href="#progress-tracking" aria-label="Permalink to &quot;Progress Tracking&quot;">â€‹</a></h3><p>Real-time progress information:</p><ul><li>Upload percentage</li><li>Upload speed (bytes/second)</li><li>Estimated remaining time</li><li>Per-chunk progress</li></ul><h3 id="lifecycle-events" tabindex="-1">Lifecycle Events <a class="header-anchor" href="#lifecycle-events" aria-label="Permalink to &quot;Lifecycle Events&quot;">â€‹</a></h3><p>Complete event system for custom logic:</p><ul><li><code>onStart</code>: Upload begins</li><li><code>onProgress</code>: Progress updates</li><li><code>onSuccess</code>: Upload completes</li><li><code>onError</code>: Error occurs</li><li><code>onPause</code>: Upload paused</li><li><code>onResume</code>: Upload resumed</li><li><code>onCancel</code>: Upload cancelled</li></ul><h2 id="use-cases" tabindex="-1">Use Cases <a class="header-anchor" href="#use-cases" aria-label="Permalink to &quot;Use Cases&quot;">â€‹</a></h2><p>ChunkFlow is perfect for:</p><ul><li><strong>Media Platforms</strong>: Video and image upload platforms</li><li><strong>Cloud Storage</strong>: File storage and backup services</li><li><strong>Content Management</strong>: CMS with large file support</li><li><strong>E-Learning</strong>: Course material and video uploads</li><li><strong>Enterprise Apps</strong>: Document management systems</li><li><strong>Any Application</strong>: That needs reliable large file uploads</li></ul><h2 id="next-steps" tabindex="-1">Next Steps <a class="header-anchor" href="#next-steps" aria-label="Permalink to &quot;Next Steps&quot;">â€‹</a></h2><p>Ready to get started? Check out the <a href="/chunkflow/guide/getting-started">Getting Started</a> guide to begin using ChunkFlow in your project.</p>`,50)])])}const g=e(s,[["render",t]]);export{h as __pageData,g as default};
